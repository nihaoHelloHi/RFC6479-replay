@[TOC](防重放- RFC6479滑动窗口算法)
# 1. 引言：从历史到现在 — 为什么我们要关心“重放攻击”

在信息与通信系统的早期，很多协议只关注“消息能否被传送完整”而忽视了“消息是否新鲜”。这种忽视催生了重放攻击（replay attack）——攻击者把合法通信的报文或认证数据保存下来，并在之后重新发送，以欺骗接收方相信那是一次新的、经过授权的交互。重放并不需要破解加密或篡改报文内容，往往只靠“时间差”或协议缺乏防护就能造成严重后果。

历史上有不少耳熟能详的案例帮助我们理解重放攻击的威力：

* 在无线领域，早期无线网络（和一些弱配置的家庭/车载无线系统）容易被窃听并重放控制或解锁信号——这导致了车钥匙、车库门、遥控门锁等被攻击的真实案例（包括所谓的“中继 / 重放”类攻击）。
* 在无线局域网（802.11）和早期对等通信中，缺乏充分的重放保护会让对手反复注入旧的数据帧，绕过会话控制或触发错误行为；这推动了对帧计数器和重放窗口的引入。
* 在金融与支付领域，若支付或转账消息可以被截取并在稍后重发，受害方可能遭受重复扣款或欺诈性转账——这类危险逼迫支付协议引入签名、时间戳与一次性令牌（OTP）。
* 在VoIP、SIP 与其他实时媒体协议中，重放录音或信令能导致欺骗、重复呼叫、服务滥用或隐私泄露。

这些实例都指向一个共同问题：**即便报文本身未被改动，只要缺乏“新鲜性证明”，合法的报文就能被当作合法的新请求再次执行。**

## 1.1 重放攻击的主要危害

重放攻击之所以危险，是因为它能把“可见但无害”的信息变成直接的安全损失或系统异常。常见危害包括：

* **身份伪装 / 权限滥用**：攻击者用旧认证消息冒充合法用户，访问受限资源。
* **重复交易与经济损失**：截取并重放付款或转账请求会造成重复扣款或财务损失。
* **会话操控与状态混乱**：在有状态协议中，重放旧消息会破坏状态机逻辑，引发错误、重复执行或资源泄露。
* **拒绝服务（资源耗尽）**：大量重放报文可耗尽处理能力、触发重复操作或让审计日志淹没在重复记录中。
* **破坏可否认性与审计完整性**：在缺乏强校验的情形下，重放使得“谁做的”审计变得不可靠。

因此，除了加密和完整性保护（如 MAC 或签名），任何面向安全的协议都必须考虑“防重放”机制作为设计要点。

## 1.2 主流的重放攻击方式（概览）

攻击者的重放技术有很多变体，常见的包括：

1. **简单录放（capture-and-replay）**：最直观的方式：记录并在合适时机原样重发。
2. **中间人重放（MitM replay）**：攻击者在通信链路中截获并在特定时机以内侧注入已捕获的报文，以便与目标交互或扰乱会话。
3. **反射/放大重放**：把重放的报文反射到第三方，利用协议行为放大影响（例如诱导第三方执行某些动作）。
4. **序列号/计数器利用**：某些实现在处理序列号回绕或窗口边界时存在错误，攻击者利用这些边界条件令旧报文仍被接受。
5. **报文修改后重放**：在保证 MAC/签名仍成立或通过回放攻击绕过某些校验的前提下，对报文的非关键字段做调整后重放（更复杂且针对性强）。
6. **延迟重放（timing-based）**：有些系统对时间敏感，攻击者在合适的时间窗口内重放，规避基于时间戳的防护。

针对这些方式，防御策略也相应发展出不同手段：简单的**时间戳/时钟同步**、**一次性随机数（nonce）**、**序列号与接收端的已接收列表**、以及**滑动窗口 / 位图（bitmap）**等机制，常与消息认证（MAC）或签名结合使用，构成端到端的防重放方案。

## 1.3 走向 RFC6479：为什么要用滑动窗口算法

在实际系统中，单纯使用时间戳会带来时钟同步和重放窗口设置的困难；而仅用全局递增序列号则要求严格的有序交付并且对丢包敏感。为了解决在有丢包、乱序传输（如IP网络）下仍能高效而稳健地防止重放的问题，工程界采用了**接收端维护的滑动窗口**策略：接收端记录最近 N 个可接受序号的接收状态，允许一定范围内的乱序但拒绝窗口之外或已见过的序号。RFC6479 就是在这种需求下对滑动窗口防重放进行了规范化的描述，明确了实现细节、边界条件以及与报文认证结合时的运作方式。

---

下面的文章中，我将集中介绍 RFC6479 定义的滑动窗口算法：它的原理、状态维护、边界情况（例如序号回绕、窗口扩展以及与认证结合时的注意事项）、以及在实际协议（如 IPsec、DTLS、某些定制加密协议）中的应用和实现要点。接下来进入算法细节与实例分析。


# 2. RFC6479滑动窗口算法具体实现
整一个滑动窗口算法的核心思想其实就是通过 **位图** + **ring环状位块** + **索引映射** 实现的， 不通过大量的位移操作来滑动窗口，而是把窗口按若干固定大小的块（block）组织成环，通过计算索引与位位置来判断/标记序号是否已见，从而避免频繁的位移操作并减少窗口更新次数，更适合大窗口和多核并行处理环境。 

--- 

感性认识1
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7ba57f1fd9f6425a918cd9353e62350a.png)

---

感性认识2
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eaf8e16faae14927862a47f6323249db.png)

## 2.1 实现思路
### 重要参数
> `uint_64 counter` [58 bits] [6 bits] 
> 58bit 用来计算索引和实际的序列号到达的大小
> 6bit 用来表示具体到块组中的哪一个bit, 0 - 63

```cpp
constexpr size_t blockBitLog = 6;                 // 块位数（2^6 = 64 位）
constexpr size_t blockBits = 1ULL << blockBitLog; // 每个块的位数
constexpr size_t ringBlocks = 1ULL << 7;          // 环形缓冲区块数
constexpr size_t windowSize = (ringBlocks - 1) * blockBits; // 滑动窗口大小
constexpr size_t blockMask = ringBlocks - 1;       // 块索引掩码
constexpr size_t bitMask = blockBits - 1;         // 位索引掩码
```
在这里我们使用的是`uint64_t`作为一块位图，所以：
- blockBitLog 就是64的对数 log64 = 6，counter(新序列号uint64_t)的后6 bits用来表示在块组中的位置
- blockBits 即每块的位数,也就是块位图容量
- ringBlocks 有多少块,块位图
- windowSize 滑动窗口的大小,(n-1)*blockBits ,余一块用来避免滑动时的边界问题, 不覆盖正在使用的块
- blockMask 索引掩码,因为在counter中作为index的实际有58bits,所以取前8位即可0xFF,换句话来说就是取余
- bitMask 同理

### 实现
- `last_` 表示上一次的序列号
- `ring_` 即环形位图,由一个一个块组组成
```cpp
// Filter: 防重放过滤器，维护滑动窗口以检测重复计数器
class Filter {
public:
    Filter() : last_(0) { ring_.fill(0); } // 初始化为空状态

    // Reset: 重置过滤器为空状态
    void Reset();

    // ValidateCounter: 检查计数器是否有效（在窗口内且未重复）
    // 参数: counter - 数据包计数器, limit - 最大允许计数器
    // 返回: 是否接受该计数器
    bool ValidateCounter(uint64_t counter, uint64_t limit);

private:
    using block = uint64_t;                       // 块类型（64 位）
    uint64_t last_;                               // 最新计数器
    std::array<block, ringBlocks> ring_;          // 环形缓冲区，记录位状态
};
```

--- 

下面是实际代码:
理解的要点在于:
- 使用 & 运算代替 %
- 区分**实际索引**和**取余索引**
- 块清零从last所在的块的**下一块**开始

```cpp
// Reset: 重置过滤器状态
// 清零 last_ 和 ring_ 数组
void Filter::Reset() {
    last_ = 0;
    ring_.fill(0);
}

// ValidateCounter: 检查计数器是否有效
// 参数: counter - 数据包计数器, limit - 最大允许计数器
// counter-->[block_idx 58bits][block_num 6bits]
// 返回: true 表示接受（新计数器或窗口内未设置），false 表示拒绝（超限或重放）
bool Filter::ValidateCounter(uint64_t counter, uint64_t limit) {
    // 检查是否超过限制
    if (counter >= limit) {
        return false;
    }

    // 计算当前计数器的块索引
    uint64_t indexBlock = counter >> blockBitLog;

    // 如果计数器大于最新值，前移窗口
    if (counter > last_) {
        uint64_t current = last_ >> blockBitLog;
        uint64_t diff = indexBlock - current;
        if (diff > ringBlocks) {
            diff = ringBlocks; // 限制清零范围
        }
        for (uint64_t i = current + 1; i <= current + diff; ++i) {
            ring_[i & blockMask] = 0; // 清零窗口内的块
        }
        last_ = counter;
    } else if (last_ - counter > windowSize) {
        // 计数器落后窗口太远，拒绝
        return false;
    }

    // 检查并设置位
    indexBlock &= blockMask;
    uint64_t indexBit = counter & bitMask;
    block old = ring_[indexBlock];
    block new_val = old | (1ULL << indexBit);
    ring_[indexBlock] = new_val;

    // 如果位未改变（已设置），表示重放
    return old != new_val;
}
```

